# Compressing Javascript

| 스크립트를 받는 네트워크 시간을 최소화한다.

- 자바스크립트 파일은 이미지 다음으로 많이 요청되는 웹 리소스이다. 페이지 크기에도 두번째로 큰 영향을 준다.
- 웹사이트 성능을 개선하기 위해 자바스크립트 전송, 로드, 실행시간을 줄이는 패턴을 사용해야한다.
- **압축**은 자바스크립트를 전송하는 네트워크 시간을 줄이는 데 도움이 될 수 있다.

## Page Weight (페이지 무게)

사람의 무게을 측정하는 것처럼 페이지의 무게(Weight)를 측정할 수 있다

- Assets
  - 이미지, HTML, CSS, 자바스크립트
  - 이미지가 페이지 무게의 대부분을 차지한다!
  - 자바스크립트는 두번째로 큰 리소스이지만 번들링, 압축, 축소등 작업할 수 있는 여지가 있다
  - **WebP**가 2020년에 사파리에서 채택되어서 페이지 무게를 크게 줄일 수 있는 가능성이 있다!(30%까지)
  - **AVIF**라는 보다 작은 크기의 이미지파일도 등장. 제일 최신. 범용성에 문제가 있음

## HTTP 압축


웹 사이트 콘텐츠를 압축하고 페이지 무게를 줄이며 대역폭 요구사항을 낮추어 성능을 향상시킨다
HTTP 데이터 압축은 다양한 방식으로 분류될수 있는데 그중 하나가 손실, 무손실이다.

### 손실압축

사진, 음악, 동영상 등 주로 멀티미디어 데이터에서 인간이 지각하기 힘든 범위의 데이터를 버리고 압축하는 방법을 사용하는 포맷

- 사람이 인지하기 어려운 정보를 제거함으로서 데이터를 절약
- 인지심리학에 기반한 기술으로 일반적인 데이터에는 적용할 수 없다
- **디지털풍화**
- JPEG
- WebP (손실압축, 무손실압축 둘다 지원)
- AVIF (손실압축, 무손실압축 둘다 지원)

### 무손실압축

압축 전 데이터와 압축 후 복구된 데이터가 정확하게 일치한다.
- 압축방식이 반복되는 표현을 줄여 최대한 수학적으로 정의하는 수학적 기법과 관련이 있다.

- PNG
- WebP (손실압축, 무손실압축 둘다 지원)
- AVIF (손실압축, 무손실압축 둘다 지원)
- 자바스크립트
  - 유효한 자바스크립트 코드를 위해 무손실압축해야한다. (손실압축하면 코드가 손상될수있으니?)
  - 불필요한 구문을 제거하고 실행에 필요한 코드로만 줄일 수 있다

### 자바스크립트 불필요한 구문 제거하기

1. 트리쉐이킹
   - 실행에 필요하지않은 코드를 번들에서 제거하기
2. minify
   - 공백, 개행, 세미콜론등 문법적으로 필수가 아닌 문자를 제거하는 과정

3. mangler
   - 변수명, 함수명, 인자명을 매우 단순화된 의미없는 이름으로 변경
   - fetchData -> d (한글자)

웹팩같은 번들러에서 minify 라이브러리, uglify 라이브러리를 가져와 통합하여 사용
ex) `terser` 라이브러리, `esbuil`

## 정적 압축 vs 동적 압축

### 정적압축

- 정적 압축은 인터넷을 통해 전송되기 전에 파일을 압축하는 기술입니다. 
- 압축된 파일은 서버에 저장되어 사용자가 요청할 때 사용자에게 제공됩니다.
- 압축된 파일은 브라우저나 디바이스에 관계없이 요청하는 모든 사용자에게 동일하게 제공되므로 이 기술을 "정적"이라고 합니다.

### 정적압축 - Gzip

- 정적 압축의 일반적인 방법 중 하나는 gzip 압축입니다. 
- Gzip 압축은 압축 알고리즘을 사용하여 인터넷을 통해 전송되기 전에 파일을 압축합니다. 
- 사용자가 압축 파일을 요청하면 서버는 압축 파일을 사용자의 브라우저로 보내고, `브라우저는 압축을 풀고` 파일을 사용자에게 표시합니다.


동적압축

- 브라우저가 리소스를 요청할 때 압축이 수행된다.
- 압축 수준이 높을수록 많은 시간이 필요하다. 자주 변경되는 콘텐츠나 애플리케이션에서 생성되는 콘테츠와 함께 동적압축을 사용하는 것이 좋다.

## 압축 알고리즘

- Gzip
- Brotil


## Accept-Encoding 헤더

## HTTP 압축
압축이 발생하는 세 가지 수준

1. 압축 파일 형식을 가지는 파일 (이미 압축된 파일)
2. 서버-클라이언트 수준 압축 (네트워크 요청, 응답할 때 압축)
3. 네트워크 홉 수준 압축

### 파일 포맷 압축
- 손실 압축: 원본데이터와 압축파일을 해제한 데이터가 정확하게 일치
  - png, gif
- 무손실 압축: 압축파일을 해제한 데이터에 작슨 손실이 있음
  - jpeg
  
webp, avif는 무손실, 손실압축 둘 다 지원


### 서버-클라이언트 압축

<img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Compression/httpenco1.png" width="300"/>

- 서버에서 압축이 수행되고 클라이언트에 도달할때까지 변경되지않고 지속되는 메시지 본문의 압축
- 서버와 브라우저는 사용할 `압축 알고리즘`이 무엇인지 협상해야한다. 서버는 그 알고리즘으로 압축하고, 브라우저는 압축파일을 해석하기 위해
- 가장 유명한 알고리즘 `gzip`, `Brotli`


### 서버와 브라우저는 압축 알고리즘을 협상하기 위해 사전컨텐츠 협상을 한다
1. 브라우저는 브라우저가 지원하는 알고리즘과 우선순위를 Accept-Encoding 헤더에 담아 서버에 전송한다.
2. 서버는 헤더를 해석하여 사용할 압축알고리즘을 선택하고 어떤 알고리즘을 사용했는지 Content-Encoding 헤더로 브라우저에게 알려준다.


## 코드 경량화
최대한 소스코드 파일의 크기를 줄이기 위해

1. mangler, minify: 코드를 짧게 변환
2. tree shaking: 미사용 코드 제거 (정적)
3. 번들링: 나중에 네트워크 요청하기

### mangler(엉망으로 만들다라는 뜻) 또는 minify
- 코드를 짧게, 용량을 줄이자
- terser, esbuild 등 라이브러리 기능
```js
// AS-IS
var x = {
    baz_: 0,
    foo_: 1,
    calc: function() {
        return this.foo_ + this.baz_;
    }
};
x.bar_ = 2;
x["baz_"] = 3;
console.log(x.calc());


```
- 공백, 개행제거
- 변수/함수/속성의 이름을 단순하고 짧은 이름으로 변경

```js
var x={o:3,foo_:1,t:function(){return this.foo_+this.o},bar_:2};console.log(x.t());
```

- 주의점은 Babel이 수행하는 트랜스파일과는 다르다는 점
- 트랜스파일 + minify: SWC, 





## 자바스크립트 비용
https://v8.dev/blog/cost-of-javascript-2019

| 다운로드 시간과 CPU 실행시간이 자바스크립트 처리의 가장 큰 비용이다.

- 자바스크립트 엔진이 자바스크립트를 파싱하고 컴파일 할 수 있는 속도는 향상되어 느리지않다!

가장 큰 주요 사항 세가지
1. 다운로드 시간
2. 실행 시간
3. 큰 인라인 스크립트


<img src="https://v8.dev/_img/cost-of-javascript-2019/reddit-js-processing.svg" width="300"/>
- 자바스크립트 엔진이 소요하는 시간은 30%정도에 불과. 나머지는 다운로드 시간


- 모바일과 데스크탑의 자바스크립트 처리성능은 다르다

### 다운로드 시간 개선하기
- 모바일 장치를 위해 자바스크립트 번들크기를 작게 유지하라
  - 작은 번들크기는 다운로드 속도를 높이고 메모리 사용량을 낮추고 CPU 비용을 줄인다
  - 하나의 큰 번들만 사용하지마라


### 실행 시간 개선하기
- 오랜 시간동안 메인스레드를 독점하고 다른 중요한 작업(사용자입력에 대한 반응)이 실행하지 못하도록하는 긴 작업을 피하라

### 큰 인라인 스크립트를 사용하지 마라
- 캐싱을 사용하지 못함


### JSON 파싱비용이 더 싸다
- JSON 문법이 자바스크립트 문법보다 훨씬 간단하기 때문에 파싱이 훨씬 효율적으로 될 수 있다.
```js
// 객체 리터럴 방식
const data = { foo: 42, bar: 1337 }; // 🐌

// JSON 문자열 형식
const data = JSON.parse('{"foo":42,"bar":1337}'); // 🚀
```
객체 리터럴 형식에 비해 JSON 문자열 형식이 훨씬 빠르다


## 청크 세분화의 트레이드오프
| 무조건 청크를 작게 만드는게 더 빠를까? 트레이드 오프를 따져봐야한다.



1. 다운로드 속도 향상 (네트워크 다운로드, 파싱까지 고려하는듯)
   - 입출력(I/O), 프로세스 간 통신(IPC) 비용등등 고려해야할 점
   - 크기가 큰 청크가 작은 청크보다 다운로드 및 브라우저 성능의 최적화 관점에서 더 효율적일 수 있다"

여러 작은 청크 보다 하나의 큰 코드를 압축하는 것이 더 좋은 결과를 보인다.

2. 캐시 히트 및 캐시 효율 향상: 
   - 작은 크기의 청크가 더 나은 캐시 효율을 보인다.
   - 청크 크기가 작으면 코드 변경시 변경이 이루어지는 청크가 적기 때문에 적은 수의 청크만 다운로드 받으면 된다. 나머지 청크는 캐시에서 꺼내서 쓴다
   - 청크 크기가 클수록 코드 변경시 다운로드 해야하는 경우가 자주 생긴다

캐시 효율성 측면에서는 작은 크기의 청크가 더 좋다

3. 빠른 실행 속도
   - 종속 모듈들이 이미 다운로드 되어있거나 캐시히트되어야한다. -> 관련된 코드를 하나의 큰 청크로 만들어야함
   - 메인 스레드를 오랫동안 점유하는 경우 청크로 나누어야함

<img src="https://patterns-dev-kr.github.io/static/58937c7284e6a04754fba3e2e06e8eb5/45da7/compressing-javascript7.png" width="300"/>

결론
- 청크수를 적절하게 유지하자. 사이트에서는 최대 10개라고 주장한다...




## 참고
1. https://www.google.com/search?q=brotoli&rlz=1C5CHFA_enKR1004KR1004&oq=brotoli+&aqs=chrome..69i57.3582j0j7&sourceid=chrome&ie=UTF-8
2. https://developer.mozilla.org/en-US/docs/Web/HTTP/Compression
3. https://almanac.httparchive.org/en/2021/page-weight